# 1.7 Linear Independence {.unnumbered}

## Definition and Characterization

::: {#def-linearindependence}

## Linear Independence
An indexed set of vectors $\{\mathbf{v}_1,\dots,\mathbf{v}_n\}$ in $\mathbb{R}^m$ is said to be linearly independent if the vector equation
$$x_1\mathbf{v}_1+x_2\mathbf{v}_2+\dots+x_n\mathbf{v}_n=\mathbf{0}$$
has only the trivial solution ($\mathbf{x}=\mathbf{0}$). Otherwise, it is said to be linearly dependent.
:::

::: {#thm-thm1-7-7}

## Theorem 7: Characterization of Linearly Dependent Sets

An indexed set $S = \{\mathbf{v}_1, \dots, \mathbf{v}_n\}$ of two or more vectors is linearly dependent if and only if at least one of the vectors in $S$ is a linear combination of the others. In fact, if $S$ is linearly dependent and $\mathbf{v}_1 \neq \mathbf{0}$, then some $\mathbf{v}_j$ (with $j > 1$) is a linear combination of the preceding vectors, $\mathbf{v}_1,\dots,\mathbf{v}_{j-1}$.
:::

::: {.proof}

## Proof of [@thm-thm1-7-7]

Let "in fact" separate the theorem into two parts. Consider the first part.

1. If there is a vector that is a linear combination of the other vectors,
$$\mathbf{v}_i=c_1\mathbf{v}_1+\dots+c_{i-1}\mathbf{v}_{i-1}+c_{i+1}\mathbf{v}_{i+1}+\dots+c_n\mathbf{v}_n,$$
move the terms into one side:
$$c_1\mathbf{v}_1+\dots+c_{i-1}\mathbf{v}_{i-1}+(-1)\mathbf{v}_i+c_{i+1}\mathbf{v}_{i+1}+\dots+c_n\mathbf{v}_n=\mathbf{0}.$$
Thus, there is a nontrivial solution for $\mathbf{c}$, where $c_i=-1$, so the set is linearly dependent.

2. If the set is linearly dependent, the vector equation $c_1\mathbf{v}_1+\dots+c_n\mathbf{v}_n=\mathbf{0}$ has nontrivial solution of $\mathbf{c}$. There exists an index $i$ where $c_i \neq 0$. Move the $i$-th term to the left hand side and the other terms to the right hand side:
$$-c_i\mathbf{v}_i=c_1\mathbf{v}_1+\dots+c_{i-1}\mathbf{v}_{i-1}+c_{i+1}\mathbf{v}_{i+1}+\dots+c_n\mathbf{v}_n.$$
Divide both sides by $-c_i$:
$$\mathbf{v}_i=\frac{c_1}{-c_i}\mathbf{v}_1+\dots+\frac{c_{i-1}}{-c_i}\mathbf{v}_{i-1}+\frac{c_{i+1}}{-c_i}\mathbf{v}_{i+1}+\dots+\frac{c_n}{-c_i}\mathbf{v}_n.$$
Hence, $\mathbf{v}_i$ is a linear combination of the other vectors in the set.

We have now proved the first part of the theorem. Let's prove the second part by induction and contradiction.

If $\mathbf{v}_j = \mathbf{0}$ ($1 < j \leq n$), $\mathbf{v}_j$ can be expressed as $0\cdot\mathbf{v}_1+\dots+0\cdot\mathbf{v}_{j-1}$, so we only consider situations that, for all $1 \leq j \leq n$, $\mathbf{v}_j\neq\mathbf{0}$.

Let $A_k=\begin{bmatrix} \mathbf{v}_1 & \cdots & \mathbf{v}_k \end{bmatrix}$, where $1 \leq k \leq n$, so $A \in \mathbb{R}^{m \times k}$.

The reduced row echelon form (RREF) of $A_1$ is $\begin{bmatrix} 1 \\ 0 \\ \vdots \\ 0 \end{bmatrix}$. If $\mathbf{v}_2$ is not a linear combination of $\mathbf{v}_1$, $\{\mathbf{v}_1, \mathbf{v}_2\}$ is linearly independent. Thus, the RREF of $A_2$ is $\begin{bmatrix} 1 & 0 \\ 0 & 1 \\ \vdots & \vdots \\ 0 & 0 \end{bmatrix}$. Similarly, the RREF of $A_3$ needs to be $\begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \\ \vdots & \vdots & \vdots \\ 0 & 0 & 0 \end{bmatrix}$, since if there is no pivot position in the third column, the solution of $A_3\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}=\mathbf{0}$ can be written as $\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}=x_3\begin{bmatrix}u_1\\u_2\\1\end{bmatrix}$, where $x_3,u_1,u_2\in\mathbb{R}$. Thus, the RREF of $A_k$ must be in the form of $\begin{bmatrix} 1 & 0 & \cdots & 0 \\ 0 & 1 & \cdots & 0 \\ \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & \cdots & 1 \\ \vdots & \vdots & \vdots & \vdots \\ 0 & 0 & 0 & 0 \end{bmatrix}$. When $k=n$, the matrix equation $A_n\mathbf{x}=\mathbf{0}$ has only the trivial solution because every column has a pivot position. Hence, $S$ is linearly independent, contradicting the stated condition that $S$ is linearly dependent.
:::

::: {.remark}

When the author first learned about linear independence, the characteristic (@thm-thm1-7-7), rather than the definition (@def-linearindependence), was taught first. That is, if none of the vectors in a set are a linear combination of the other vectors, the set is linearly independent. This characterization may more intuitively illustrates the name "linear independence" than the definition does, as every vector is "independent" of the other vectors.
:::

## Pivot Columns and Linear Independence

::: {#exr-1-7-27}

## T27

How many pivot columns must a $7 \times 5$ matrix have if its columns are linearly independent?
:::

::: {#sol-1-7-27}

## Solution to [@exr-1-7-27]

Recall the definition of linear indenpendence: $A\mathbf{x}=\mathbf{0}$ has only the trivial solution ($\mathbf{x}=\mathbf{0}$). There must be 5 pivot columns in $A$'s row echelon form (REF). Otherwise, the free variable(s) will produce solutions other than $\mathbf{0}$.

If we generalize the situation to $A \in \mathbb{R}^{m \times n}$, $n$ pivot columns are required to avoid free variables. Therefore, the columns of $A$ are necessarily linearly dependent when $n > m$, as there are no enough rows to generate $n$ pivot columns (Theorem 8).
:::

::: {.remark}

What if there are columns without a pivot position?

Let the $k$-th column be one of those columns. Then, $x_k$ is a free variable. According to the proof of [@thm-thm1-7-7], $\mathbf{v}_k \in \text{span}\{\mathbf{v}_1,\dots,\mathbf{v}_{k-1}\}$. In addition, we can observe the solution of the matrix equation $A\mathbf{x}=\mathbf{0}$, $\mathbf{x}=x_k\mathbf{u}+x_{k_1}\mathbf{u}_1+\dots+x_{k_t}\mathbf{u}_t$, where $\mathbf{u},\mathbf{u}_1,\dots,\mathbf{u}_t$ are the vectors obtained from the RREF and $x_{k_1},\dots,x_{k_t}$ are other free variables. Set $x_{k_1},\dots,x_{k_t}$ equal to zero:
$$\mathbf{x}=x_k\mathbf{u}.$$
Substitute this into the vector equation, $x_1\mathbf{v}_1+\dots+x_n\mathbf{v}_n=\mathbf{0}$:
$$x_k u_1\mathbf{v}_1+\dots+x_k u_k\mathbf{v}_k+\dots+x_k u_n\mathbf{v}_n=\mathbf{0}.$$
Since $x_k$ is a free variable, we can divide the equation by $x_k$ if $x_k \neq 0$. Then, separate the $k$-th term to one side ($u_k=1$):
$$\mathbf{v}_k=(-u_1)\mathbf{v}_1+\dots+(-u_n)\mathbf{v}_n.$$
Since the matrix has been simplified to its RREF, $u_{k+1},\dots,u_n$ all equal zero. Then,
$$\mathbf{v}_k=(-u_1)\mathbf{v}_1+\dots+(-u_{k-1})\mathbf{v}_{k-1}.$$
Thus, the $k$-th column of the RREF exactly shows the coefficients of how it can be written as a linear combination of the preceding vectors.
:::

::: {#exr-1-7-28}

## T28

How many pivot columns must a $5 \times 7$ matrix have if its columns span $\mathbb{R}^5$?
:::

::: {#sol-1-7-28}

## Solution to [@exr-1-7-28]

That the vectors span $\mathbb{R}^5$ means that, for all $\mathbf{b} \in \mathbb{R}^5$, $\mathbf{b}$ can be expressed as a linear combination of the vectors. That is, the matrix equation $A\mathbf{x}=\mathbf{b}$ is consistent. Thus, each of the 5 rows of the REF of A must have a pivot position.

For $A \in \mathbb{R}^{m \times n}$, $m$ pivot columns are needed if $A$'s columns span $\mathbb{R}^m$. This also states that a minimum set of $m$ vectors can span $\mathbb{R}^m$ if the vectors are linearly independent.
:::

::: {.remark}

Consider $A \in \mathbb{R}^{3\times3}$ with only two pivot positions. Obviously, the columns of $A$ do not span $\mathbb{R}^3$ and can only form a plane. But it is also mistaken to say the columns span $\mathbb{R}^2$ because the vectors are in $\mathbb{R}^3$.

```{r, message=FALSE}
library(plotly)

# ----------------- small math helpers ---------------------------------------
cross_prod <- function(a, b) c(
  a[2]*b[3] - a[3]*b[2],
  a[3]*b[1] - a[1]*b[3],
  a[1]*b[2] - a[2]*b[1]
)

# arrowhead builder that does not depend on extra packages
arrow_lines_for_tip2 <- function(p, d, size = 0.18) {
  if (sqrt(sum(d^2)) < 1e-9) return(NULL)
  ux <- d / sqrt(sum(d^2))
  arb <- if (abs(ux[1]) < 0.9) c(1,0,0) else c(0,1,0)
  v_perp1 <- cross_prod(arb, ux)
  if (sqrt(sum(v_perp1^2)) < 1e-6) { arb <- c(0,0,1); v_perp1 <- cross_prod(arb, ux) }
  v_perp1 <- v_perp1 / sqrt(sum(v_perp1^2))
  base1 <- p - ux * size + v_perp1 * (size / 2)
  base2 <- p - ux * size - v_perp1 * (size / 2)
  list(line1 = rbind(base1, p), line2 = rbind(base2, p))
}

# ----------------- main plotting function -----------------------------------
# vectors: list of lists, each with fields: vec (numeric length-3), color, name, width, start (defaults to origin)
# planes: list of lists, each with fields: v1 (len3), v2 (len3), color, opacity, n (grid density), scale
# xrange/yrange/zrange: either NULL (auto) or length-2 numeric c(min,max)
# camera_eye: numeric length-3 vector, e.g. c(0.5, -1.5, 0.7)
# zoom: numeric > 0; zoom > 1 moves camera closer (zoom in), <1 moves camera farther (zoom out)
make_3d_linear_plot <- function(vectors = list(), planes = list(),
                                L = NULL, head_size = 0.18, plane_n = 40,
                                axis_width = 4, show_axes = TRUE,
                                xrange = NULL, yrange = NULL, zrange = NULL,
                                camera_eye = c(0.5, -1.5, 0.7),
                                zoom = 1) {

  # validate basic inputs
  if (!is.numeric(camera_eye) || length(camera_eye) != 3) stop("camera_eye must be numeric length 3")
  if (!is.numeric(zoom) || zoom <= 0) stop("zoom must be a positive number")
  if (!is.null(xrange) && length(xrange) != 2) stop("xrange must be NULL or length-2 numeric")
  if (!is.null(yrange) && length(yrange) != 2) stop("yrange must be NULL or length-2 numeric")
  if (!is.null(zrange) && length(zrange) != 2) stop("zrange must be NULL or length-2 numeric")

  # sanitize vector entries and provide defaults
  vectors <- lapply(vectors, function(v) {
    v$vec   <- as.numeric(v$vec)
    if (length(v$vec) != 3) stop("each vector must be length 3")
    v$start <- if (!is.null(v$start)) as.numeric(v$start) else c(0,0,0)
    if (length(v$start) != 3) stop("start must be length 3")
    v$color <- if (!is.null(v$color)) v$color else "red"
    v$name  <- if (!is.null(v$name)) v$name else ""
    v$width <- if (!is.null(v$width)) v$width else 6
    v
  })

  # sanitize planes and defaults
  planes <- lapply(planes, function(p) {
    p$v1 <- as.numeric(p$v1); p$v2 <- as.numeric(p$v2)
    if (length(p$v1)!=3 || length(p$v2)!=3) stop("plane v1 and v2 must be length 3")
    p$color <- if (!is.null(p$color)) p$color else "lightblue"
    p$opacity <- if (!is.null(p$opacity)) p$opacity else 0.45
    p$n <- if (!is.null(p$n)) p$n else plane_n
    p$scale <- if (!is.null(p$scale)) p$scale else 1.8
    p$name <- if (!is.null(p$name)) p$name else ""
    p
  })

  # compute suggested axis limit L if not provided
  if (is.null(L)) {
    coords <- numeric(0)
    if (length(vectors) > 0) {
      for (v in vectors) coords <- c(coords, v$start + v$vec, v$start)
    }
    if (length(planes) > 0) {
      for (p in planes) {
        s <- p$scale; t <- p$scale
        corners <- rbind(
          s * p$v1 + t * p$v2,
          s * p$v1 - t * p$v2,
          -s * p$v1 + t * p$v2,
          -s * p$v1 - t * p$v2
        )
        coords <- c(coords, as.numeric(corners))
      }
    }
    maxc <- if (length(coords) == 0) 1 else max(abs(coords))
    L <- max(1.2 * maxc, 2)
  }

  # default ranges: symmetric box [-L,L] unless user overrides
  xrange <- if (is.null(xrange)) c(-L, L) else xrange
  yrange <- if (is.null(yrange)) c(-L, L) else yrange
  zrange <- if (is.null(zrange)) c(-L, L) else zrange

  # build plane surfaces (precompute X,Y,Z for each plane)
  plane_surfaces <- lapply(planes, function(p) {
    s <- seq(-p$scale, p$scale, length.out = p$n)
    t <- seq(-p$scale, p$scale, length.out = p$n)
    g <- expand.grid(s = s, t = t)
    X <- matrix(g$s * p$v1[1] + g$t * p$v2[1], nrow = length(s), ncol = length(t))
    Y <- matrix(g$s * p$v1[2] + g$t * p$v2[2], nrow = length(s), ncol = length(t))
    Z <- matrix(g$s * p$v1[3] + g$t * p$v2[3], nrow = length(s), ncol = length(t))
    list(X = X, Y = Y, Z = Z)
  })

  # start building plotly figure
  fig <- plot_ly()

  # add planes first (so vectors/arrowheads are on top)
  if (length(planes) > 0) {
    for (i in seq_along(planes)) {
      p <- planes[[i]]
      surf <- plane_surfaces[[i]]
      cols <- list(c(0,1), c(p$color, p$color))
      fig <- fig %>%
        add_surface(x = surf$X, y = surf$Y, z = surf$Z,
                    opacity = p$opacity, showscale = FALSE, hoverinfo = "none",
                    colorscale = cols, name = p$name, showlegend = FALSE)
    }
  }

  # axes and arrowheads
  if (isTRUE(show_axes)) {
    fig <- fig %>%
      add_trace(type = "scatter3d", mode = "lines",
                x = c(xrange[1], xrange[2]), y = c(0,0), z = c(0,0),
                line = list(color = "black", width = axis_width), showlegend = FALSE) %>%
      add_trace(type = "scatter3d", mode = "lines",
                x = c(0,0), y = c(yrange[1], yrange[2]), z = c(0,0),
                line = list(color = "black", width = axis_width), showlegend = FALSE) %>%
      add_trace(type = "scatter3d", mode = "lines",
                x = c(0,0), y = c(0,0), z = c(zrange[1], zrange[2]),
                line = list(color = "black", width = axis_width), showlegend = FALSE)

    # axis arrowheads placed at positive ends of the axis ranges
    x_tip <- c(xrange[2], 0, 0); y_tip <- c(0, yrange[2], 0); z_tip <- c(0, 0, zrange[2])
    x_head <- arrow_lines_for_tip2(x_tip, c(1,0,0), size = head_size*0.9)
    y_head <- arrow_lines_for_tip2(y_tip, c(0,1,0), size = head_size*0.9)
    z_head <- arrow_lines_for_tip2(z_tip, c(0,0,1), size = head_size*0.9)

    if (!is.null(x_head)) fig <- fig %>% add_trace(type = "scatter3d", mode = "lines",
                x = c(x_head$line1[,1], NA, x_head$line2[,1]),
                y = c(x_head$line1[,2], NA, x_head$line2[,2]),
                z = c(x_head$line1[,3], NA, x_head$line2[,3]),
                line = list(color = "black", width = axis_width), showlegend = FALSE)
    if (!is.null(y_head)) fig <- fig %>% add_trace(type = "scatter3d", mode = "lines",
                x = c(y_head$line1[,1], NA, y_head$line2[,1]),
                y = c(y_head$line1[,2], NA, y_head$line2[,2]),
                z = c(y_head$line1[,3], NA, y_head$line2[,3]),
                line = list(color = "black", width = axis_width), showlegend = FALSE)
    if (!is.null(z_head)) fig <- fig %>% add_trace(type = "scatter3d", mode = "lines",
                x = c(z_head$line1[,1], NA, z_head$line2[,1]),
                y = c(z_head$line1[,2], NA, z_head$line2[,2]),
                z = c(z_head$line1[,3], NA, z_head$line2[,3]),
                line = list(color = "black", width = axis_width), showlegend = FALSE)
  }

  # add vectors (lines + arrowheads)
  if (length(vectors) > 0) {
    for (i in seq_along(vectors)) {
      v <- vectors[[i]]
      start <- v$start
      tip   <- start + v$vec
      fig <- fig %>%
        add_trace(type = "scatter3d", mode = "lines+markers",
                  x = c(start[1], tip[1]), y = c(start[2], tip[2]), z = c(start[3], tip[3]),
                  line = list(color = v$color, width = v$width),
                  marker = list(size = 2),
                  name = v$name)
      ah <- arrow_lines_for_tip2(tip, v$vec, size = head_size)
      if (!is.null(ah)) {
        fig <- fig %>% add_trace(type = "scatter3d", mode = "lines",
                  x = c(ah$line1[,1], NA, ah$line2[,1]),
                  y = c(ah$line1[,2], NA, ah$line2[,2]),
                  z = c(ah$line1[,3], NA, ah$line2[,3]),
                  line = list(color = v$color, width = v$width), showlegend = FALSE)
      }
    }
  }

  # origin marker
  fig <- fig %>% add_markers(x = 0, y = 0, z = 0,
                             marker = list(size = 4, color = "black"), showlegend = FALSE)

  # camera setup: apply zoom by scaling the eye vector (zoom > 1 => closer)
  cam_eye_scaled <- as.numeric(camera_eye) * (1 / zoom)
  camera_list <- list(eye = list(x = cam_eye_scaled[1], y = cam_eye_scaled[2], z = cam_eye_scaled[3]))

  # final layout
  fig <- fig %>% layout(scene = list(
    aspectmode = "cube",
    xaxis = list(title = "X", range = xrange,
                 showgrid = TRUE, zeroline = FALSE, showbackground = FALSE),
    yaxis = list(title = "Y", range = yrange,
                 showgrid = TRUE, zeroline = FALSE, showbackground = FALSE),
    zaxis = list(title = "Z", range = zrange,
                 showgrid = TRUE, zeroline = FALSE, showbackground = FALSE),
    camera = camera_list
  ))

  fig
}

# ----------------- Example usage 1: default/autorange -----------------------
vecs <- list(
  list(vec = c(1, 0, 0), color = "red",   name = "v1"),
  list(vec = c(0, 1, 1), color = "green", name = "v2"),
  list(vec = c(.8, .8, .8), color = "orange", name = "v3")
)

pls <- list(
  list(v1 = c(1,0,0), v2 = c(0,1,1), color = "lightblue", opacity = 0.45, scale = 1.8, n = 40)
)

# Auto axis-range (L computed internally), default camera and zoom=1
fig1 <- make_3d_linear_plot(vectors = vecs, planes = pls)
fig1  # print/plot the figure in notebook or Quarto

```
:::

## Random Thoughts About the Characterization ([@thm-thm1-7-7])

::: {.remark}

The textbook warns that [@thm-thm1-7-7] does not guarantee that **every** vector in a linearly dependent set is a linear combination of the other vectors.

The simplest example of this is a zero vector. Consider a linearly independent set $S=\{\mathbf{v}_1,\dots,\mathbf{v}_n\}$. Let $S'=S \cup \{\mathbf{0}\}$, then $S'$ is a linearly dependent set (Theorem 9). Only $\mathbf{0}$ in $S'$ is a linear combination of the other vectors ($0\mathbf{v}_1+\dots+0\mathbf{v}_n$) because, for all $1 \leq k \leq n$, adding a zero vector doesn't change the span of the other vectors. Thus, $\mathbf{v}_k \notin \text{span}\{\mathbf{v}_1,\dots,\mathbf{v}_{k-1},\mathbf{v}_{k+1},\dots,\mathbf{v}_n,\mathbf{0}\}$. Similarly, we can add, rather than a zero vector, $t\mathbf{v}_k$ to $S$, where $t \neq 0$ and $1 \leq k \leq n$. Denote this new set as $S'=S \cup \{t\mathbf{v}_k\}$. Only the newly added vector, $t\mathbf{v}_k$, and $\mathbf{v}_k$ are a linear combination of the other vectors: $t\mathbf{v}_k=t\cdot\mathbf{v}_k$ and $\mathbf{v}_k=\frac{1}{t}\cdot t\mathbf{v}_k$. Moreover, these are also the only ways by which they can be written as a linear combination of the other vectors.

Then, what if we add a linear combination of some of the vectors in $S$. Formally, let $V=\{\mathbf{v}_{i_1},\dots,\mathbf{v}_{i_m}\} \subseteq S$. Consider the vector $\mathbf{w}=c_1\mathbf{v}_{i_1}+\dots+c_m\mathbf{v}_{i_m}$, where $c_1 \cdots c_m \neq 0$. $S'=S \cup \{\mathbf{w}\}$ is linearly dependent. Let $V'=V \cup \{\mathbf{w}\}$. Since $\mathbf{c}$ is non-zero, for all $\mathbf{u}\in V'$, $\mathbf{u}$ can be expressed as a unique linear combination of the other vectors in $V'$. The case of the vectors not in $V'$ is the same. They cannot be written as a linear combination of the other vectors because adding a vector already in the span doesn't change the span.

Let's consider a general case in [@prp-1-7-char].
:::

::: {#prp-1-7-char}

Suppose $S=\{\mathbf{v}_1,\dots,\mathbf{v}_n\}$ is an arbitrary set of non-zero vectors in $\mathbb{R}^m$. It is always possible to partition $S$ into $p$ non-empty subsets, $V_1,\dots,V_p$, such that, for every $|V_k|>1$ and $\mathbf{v}_i\in V_k$, $\mathbf{v}_i\in\text{span}(V_k\setminus \{\mathbf{v}_i\})$. In addition, if a vector, $\mathbf{v}_i\in V_k$, is in $\text{span}(S\setminus\{\mathbf{v}_i\})$, it can only be written as a linear combination of the other vectors in $V_k$.  
:::

::: {.proof}

## Proof of [@prp-1-7-char]

The description definitely complicates the thing a lot. Observe that if two subsets with sizes greater than one, $V_i,V_j$, satisfy that every vector in a subset can only be written as a linear combination using the other vectors in the subset, $V_i \cup V_j$ also meets the requirement.

Thus, the **simplest** (not unique) partition is making each $\mathbf{v}_i\notin\text{span}(S\setminus\{\mathbf{v}_i\})$ a single subset. Other vectors that can be represented as a linear combination are put in a same set.
:::

::: {.remark}

What this simplest construction says is that, except for the vectors that are not a linear combination of the other vectors, the remainders are. Pretty naive...

However, this is not what the author was originally thinking. The initial idea was about the finest partition, in which case, for each subset, it is impossible to split it into multiple subsets while satisfying the condition.
:::